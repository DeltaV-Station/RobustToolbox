using System;
using System.Collections.Generic;
using System.Linq;
using Robust.Shared.Interfaces.GameObjects;
using Robust.Shared.Interfaces.Reflection;
using Robust.Shared.IoC;
using Robust.Shared.Log;
using Robust.Shared.Serialization;
using Robust.Shared.Utility;
using YamlDotNet.RepresentationModel;

namespace Robust.Shared.Prototypes
{
    public class ComponentDataManager : IComponentDataManager
    {
        [Dependency] private readonly IComponentFactory _componentFactory = default!;
        [Dependency] private readonly IReflectionManager _reflectionManager = default!;

        private Dictionary<Type, Type> _customDataClasses = new ();

        public void RegisterCustomDataClasses()
        {
            var iComponent = typeof(IComponent);

            foreach (var type in _reflectionManager.FindTypesWithAttribute<CustomDataClassAttribute>())
            {
                if (!iComponent.IsAssignableFrom(type))
                {
                    Logger.Error("Type {0} has CustomDataClassAttribute but does not implement IComponent.", type);
                    continue;
                }

                var attribute = (CustomDataClassAttribute?)Attribute.GetCustomAttribute(type, typeof(CustomDataClassAttribute));
                if (attribute == null)
                {
                    Logger.Error("Type {0}: CustomDataClassAttribute could not be found.", type);
                    continue;
                }

                var customDataClass = attribute.ClassName;
                //var customDataClass = _reflectionManager.GetType(className);
                /*if (customDataClass == null)
                {
                    Logger.Error("CustomDataClass {0} could not be found for type {1}.",className, type);
                    continue;
                }*/

                _customDataClasses.Add(type, customDataClass);
            }
        }

        private Dictionary<Type, Type> _cachedAutoGeneratedTypes = new();

        private Type GetComponentDataType(string compName)
        {
            var compType = _componentFactory.GetRegistration(compName).Type;
            if (_customDataClasses.TryGetValue(compType, out var customDataClass))
            {
                return customDataClass;
            }

            if (_cachedAutoGeneratedTypes.TryGetValue(compType, out var dataClass))
            {
                return dataClass;
            }

            var generatedType = _reflectionManager.GetType($"{compType.Namespace}.{compType.Name}_AUTODATA");
            if (generatedType == null)
                throw new InvalidProgramException($"No autogenerated Dataclass found for component {compType}");
            _cachedAutoGeneratedTypes.Add(compType, generatedType);
            return generatedType;
        }

        #region Populating

        public void PopulateComponent(IComponent comp, ComponentData values)
        {
            var def = GetComponentDataDefinition(comp.Name);

            foreach (var fieldDefinition in def)
            {
                var value = values.GetValue(fieldDefinition.Tag);
                if(value == null) continue;
                fieldDefinition.SetValue(comp, value);
            }
        }


        public void PushInheritance(string compName, ComponentData source, ComponentData target)
        {
            foreach (var tag in source.Tags)
            {
                if(target.GetValue(tag) == null)
                    target.SetValue(tag, source.GetValue(tag));
            }
        }

        #endregion

        #region Parsing

        private readonly Dictionary<string, IYamlFieldDefinition[]> _dataDefinitions = new();

        public YamlMappingNode? SerializeNonDefaultComponentData(IComponent comp)
        {
            var mapping = new YamlMappingNode
            {
                {"type", comp.Name}
            };
            //todo Paul: serialize all non-default (default & prototype) values
            //todo Paul: return null if no non-default values
            throw new NotImplementedException();
        }

        public IYamlFieldDefinition[] GetComponentDataDefinition(string compName)
        {
            if (!_dataDefinitions.TryGetValue(compName, out var dataDefinition))
            {
                dataDefinition = GenerateAndCacheDataDefinition(compName);
            }

            return dataDefinition;
        }

        public ComponentData GetEmptyComponentData(string compName)
        {
            var compData = (ComponentData?)Activator.CreateInstance(GetComponentDataType(compName));
            if (compData == null)
                throw new Exception($"Failed creating instance of dataclass of component {compName}");

            return compData;
        }

        private IYamlFieldDefinition[] GenerateAndCacheDataDefinition(string compName)
        {
            var compType = _componentFactory.GetRegistration(compName).Type;
            var dataDef = new List<IYamlFieldDefinition>();
            foreach (var fieldInfo in compType.GetAllFields())
            {
                //todo Paul: Attribute.GetCustomAttribute()
                var yamlFieldAttribute =
                    fieldInfo.CustomAttributes.FirstOrDefault(a => a.AttributeType == typeof(YamlFieldAttribute));
                if (yamlFieldAttribute == null) continue;

                var tag = (string)yamlFieldAttribute.ConstructorArguments[0].Value!;
                dataDef.Add(new YamlFieldDefinition(tag, fieldInfo));
            }

            foreach (var propertyInfo in compType.GetAllProperties())
            {
                var yamlFieldAttribute =
                    propertyInfo.CustomAttributes.FirstOrDefault(a => a.AttributeType == typeof(YamlFieldAttribute));
                if (yamlFieldAttribute == null) continue;

                var tag = (string)yamlFieldAttribute.ConstructorArguments[0].Value!;
                dataDef.Add(new YamlPropertyDefinition(tag, propertyInfo));
            }

            var res = dataDef.ToArray();

            _dataDefinitions.Add(compName, res);

            return res;
        }

        public ComponentData ParseComponentData(string compName, YamlMappingNode mapping, YamlObjectSerializer.Context? context = null)
        {
            //var dataDefinition = GetComponentDataDefinition(compName);
            var ser = YamlObjectSerializer.NewReader(mapping, context);

            var data = GetEmptyComponentData(compName);
            data.ExposeData(ser);

            //todo if (mapping.Children.Count != 0)
            //    throw new PrototypeLoadException($"Not all values of component {compName} were consumed (Not consumed: {string.Join(',',mapping.Children.Select(n => n.Key))})");

            return data;
        }

        #endregion
    }
}
