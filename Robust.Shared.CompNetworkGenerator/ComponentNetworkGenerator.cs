using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Robust.Shared.CompNetworkGenerator
{
    public class ComponentNetworkGenerator : ISourceGenerator
    {
        private const string ClassAttributeName = "Robust.Shared.AutoGenerated.AutoGenerateComponentStateAttribute";
        private const string MemberAttributeName = "Robust.Shared.AutoGenerated.AutoNetworkedFieldAttribute";
        private const string AttributesFile = "GenerateTypedNameReferencesAttribute";

        private const string AttributesCode = @"// <auto-generated />
using System;
using JetBrains.Annotations;
using Robust.Shared.GameObjects;

namespace Robust.Shared.AutoGenerated;

[AttributeUsage(AttributeTargets.Class, Inherited = false)]
[BaseTypeRequired(typeof(Component))]
public sealed class AutoGenerateComponentStateAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public sealed class AutoNetworkedFieldAttribute : Attribute { }
    ";

        private static string GenerateSource(INamedTypeSymbol classSymbol, CSharpCompilation comp)
        {
            var nameSpace = classSymbol.ContainingNamespace.ToDisplayString();
            var componentName = classSymbol.Name;
            var stateName = $"{componentName}_AutoState";

            var members = classSymbol.GetMembers();
            var Fields = new List<(ITypeSymbol Type, string FieldName)>();

            foreach (var mem in members)
            {
                var attrs = mem.GetAttributes();
                if (mem is IFieldSymbol field)
                {

                }

                if (mem is IPropertySymbol prop)
                {
                    if (prop.SetMethod == null)
                    {
                        // error
                    }

                    if (prop.GetMethod == null)
                    {
                        // error
                    }


                }

            }

            if (Fields.Count == 0)
            {
                // error
            }

            var reimports = "";

            // something like:
            //     public string Name = default!;
            //     public int Count = default!;
            var stateFields = "";

            // something like:
            //             Name = component.Name,
            //             Count = component.Count,
            var getStateInit = "";

            var handleStateSetters = "";

            return $@"// <auto-generated />
{reimports}
using Robust.Shared.GameStates;

namespace {nameSpace};

partial class {stateName} : ComponentState
{{
{stateFields}
}}

partial class {componentName}_AutoNetworkSystem : EntitySystem
{{
    public override Initialize()
    {{
        SubscribeLocalEvent<{componentName}, ComponentGetState>(OnGetState);
        SubscribeLocalEvent<{componentName}, ComponentHandleState>(OnHandleState);
    }}

    private void OnGetState(EntityUid uid, {componentName} component, ref ComponentGetState args)
    {{
        args.State = new {stateName}
        {{
{getStateInit}
        }};
    }}

    private void OnHandleState(EntityUid uid, {componentName} component, ref ComponentHandleState args)
    {{
        if (args.Current is not {stateName} state)
            return;
{handleStateSetters}
    }}
}}
";
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Add attribute source
            var comp = (CSharpCompilation) context.Compilation;
            if (comp.GetTypeByMetadataName(ClassAttributeName) == null || comp.GetTypeByMetadataName(MemberAttributeName) == null)
                context.AddSource(AttributesFile, SourceText.From(AttributesCode, Encoding.UTF8));
            if (!(context.SyntaxReceiver is NameReferenceSyntaxReceiver receiver))
            {
                return;
            }

            // Generate component sources and add
                // get all types with attr

        }

        private IReadOnlyList<INamedTypeSymbol> GetAnnotatedTypes(in GeneratorExecutionContext context,
            CSharpCompilation comp, NameReferenceSyntaxReceiver receiver)
        {
            var options = (CSharpParseOptions) comp.SyntaxTrees[0].Options;
            var compilation =
                comp.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(AttributesCode, Encoding.UTF8), options));
            var symbols = new List<INamedTypeSymbol>();
            var attributeSymbol = compilation.GetTypeByMetadataName(ClassAttributeName);
            foreach (var candidateClass in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
                var typeSymbol = model.GetDeclaredSymbol(candidateClass);
                var relevantAttribute = typeSymbol.GetAttributes().FirstOrDefault(attr =>
                    attr.AttributeClass != null &&
                    attr.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default));

                if (relevantAttribute == null)
                {
                    continue;
                }

                symbols.Add(typeSymbol);
            }

            return symbols;
        }


        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new NameReferenceSyntaxReceiver());
        }
    }
}
