preset raw;

#include "/Shaders/Internal/shadow_cast_shared.swsl"

const float LIGHTING_HEIGHT = 1;

const float g_MinVariance = 0;

varying vec2 worldPosition;

uniform vec4 lightColor;
// Position of the light, in world coordinates.
uniform vec2 lightCenter;
uniform float lightRange;
uniform float lightPower;
uniform float lightIndex;
uniform sampler2D shadowMap;

void vertex()
{
    vec3 transformed = modelMatrix * vec3(VERTEX, 1.0);
    worldPosition = transformed.xy;
    transformed = projectionMatrix * viewMatrix * transformed;

    VERTEX = transformed.xy;
}

float ChebyshevUpperBound(vec2 moments, float t)
{
    // One-tailed inequality valid if t > Moments.x
    float p = float(t <= moments.x);
    // Compute variance.
    float variance = moments.y - (moments.x * moments.x);
    variance = max(variance, g_MinVariance);
    // Compute probabilistic upper bound.
    float d = t - moments.x;
    float p_max = variance / (variance + d*d);
    return max(p, p_max);
}

float ShadowContribution(vec2 LightTexCoord, float DistanceToLight)
{
    // Read the moments from the variance shadow map.
    vec2 moments = texture(shadowMap, LightTexCoord).xy;
    // Compute the Chebyshev upper bound.
    return ChebyshevUpperBound(moments, DistanceToLight);
}

float shadowContrib(vec2 diff)
{
    float dist = length(diff);

    return ChebyshevUpperBound(occludeDepth(diff, shadowMap, lightIndex), dist);
}

void fragment()
{
    float mask = texture(TEXTURE, UV).r;

    vec2 diff = worldPosition - lightCenter;

    vec2 perpendicular = normalize(cross(vec3(diff, 0), vec3(0, 0, 1)).xy) * 1.0 / 32.0;

    float ourDist = length(diff);

    vec2 occlDist = occludeDepth(diff, shadowMap, lightIndex);

    float distRatio = (ourDist - occlDist.x) / occlDist.x / 2;

    perpendicular *= distRatio;

    /*
    float occlusion = float(doesOcclude(diff, shadowMap, lightIndex, 2.0/32.0));


    occlusion += float(doesOcclude(diff + perpendicular, shadowMap, lightIndex, 2.0/32.0));
    occlusion += float(doesOcclude(diff - perpendicular, shadowMap, lightIndex, 2.0/32.0));
    occlusion += float(doesOcclude(diff + perpendicular * 2, shadowMap, lightIndex, 2.0/32.0));
    occlusion += float(doesOcclude(diff + perpendicular * 2, shadowMap, lightIndex, 2.0/32.0));
    occlusion += float(doesOcclude(diff + perpendicular * 3, shadowMap, lightIndex, 2.0/32.0));
    occlusion += float(doesOcclude(diff + perpendicular * 3, shadowMap, lightIndex, 2.0/32.0));

    occlusion /= 7;*/

    float occlusion = ChebyshevUpperBound(occlDist, ourDist);


    occlusion += shadowContrib(diff + perpendicular);
    occlusion += shadowContrib(diff - perpendicular);
    occlusion += shadowContrib(diff + perpendicular * 2);
    occlusion += shadowContrib(diff - perpendicular * 2);
    occlusion += shadowContrib(diff + perpendicular * 3);
    occlusion += shadowContrib(diff - perpendicular * 3);


    occlusion /= 7;

    if (occlusion == 0.0)
    {
        discard;
    }

    float dist = dot(diff, diff) + LIGHTING_HEIGHT;
    float val = clamp((1 - clamp(sqrt(dist) / lightRange, 0, 1)) * (1 / (sqrt(dist + 1))), 0, 1);

    val *= lightPower;
    val *= mask;

    COLOR = vec4(lightColor.rgb, val * occlusion);
}
