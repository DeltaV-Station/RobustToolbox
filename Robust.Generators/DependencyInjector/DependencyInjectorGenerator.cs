using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Robust.Generators.DependencyInjector;

[Generator]
public sealed class DependencyInjectorGenerator : IIncrementalGenerator
{
    private const string DependencyAttributeName = "Robust.Shared.IoC.DependencyAttribute";
    private const string DependencyInjectorName = "Robust.Shared.IoC.IDependencyInjector";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var injectableTypeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            DependencyAttributeName,
            static (node, _) => node is { Parent.Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax } }
                or { Parent.Parent: PropertyDeclarationSyntax { Parent: ClassDeclarationSyntax } },
            static (syntaxContext, _) =>
            {
                return (ClassDeclarationSyntax)syntaxContext.TargetNode.Parent!.Parent!.Parent!;
            }).Collect();

        var injectTypes = injectableTypeDeclarations.Combine(context.CompilationProvider)
            .SelectMany((tuple, cancel) =>
            {
                var (typeDecls, compilation) = tuple;

                var dependencyAttributeType = compilation.GetTypeByMetadataName(DependencyAttributeName);
                var dependencyInjectorType = compilation.GetTypeByMetadataName(DependencyInjectorName);
                if (dependencyAttributeType == null || dependencyInjectorType == null)
                    return Enumerable.Empty<InjectorTypeData>();

                var typesToDo = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

                foreach (var typeDecl in typeDecls)
                {
                    cancel.ThrowIfCancellationRequested();

                    var semanticModel = compilation.GetSemanticModel(typeDecl.SyntaxTree);
                    var declaredSymbol = semanticModel.GetDeclaredSymbol(typeDecl);
                    if (declaredSymbol is not INamedTypeSymbol symbol)
                        continue;

                    typesToDo.Add(symbol);
                }

                var result = new List<InjectorTypeData>();

                foreach (var type in typesToDo)
                {
                    var injectorData = MakeInjectorDataForType(
                        type,
                        dependencyAttributeType,
                        dependencyInjectorType,
                        typesToDo,
                        cancel);

                    if (injectorData == null)
                        continue;

                    result.Add(injectorData);
                }

                return result;
            })
            .WithTrackingName("InjectTypes");

        context.RegisterSourceOutput(
            injectTypes,
            (productionContext, injectData) =>
            {
                var cancel = productionContext.CancellationToken;

                var (containingTypesStart, containingTypesEnd) =
                    Helpers.GenerateContainingTypeCode(injectData.ContainingDeclarations);

                var source = new StringBuilder();
                source.AppendLine("""
                    // <auto-generated/>
                    using System;
                    using System.Runtime.CompilerServices;
                    using Robust.Shared.IoC;

                    """);

                if (injectData.Namespace != null)
                {
                    source.AppendLine($"""
                        namespace {injectData.Namespace};

                        """);
                }

                if (containingTypesStart != "")
                    source.AppendLine(containingTypesStart);

                source.AppendLine($$"""
                    {{Helpers.GetPartialTypeDefinitionLine(injectData.TypeDeclaration)}}{{(injectData.BaseTypeIsInjector ? "" : " : IDependencyInjector")}}
                    {
                    """);

                if (!injectData.BaseTypeIsInjector)
                {
                    source.AppendLine("""
                            Type[] IDependencyInjector.ReportDependencies()
                            {
                                return GeneratedReportDependencies(0);
                            }

                            void IDependencyInjector.InjectDependencies(ReadOnlySpan<object> dependencies)
                            {
                                GeneratedInjectDependencies(dependencies);
                            }

                        """);
                }

                string virtualModifier;
                if (injectData.BaseTypeIsInjector)
                    virtualModifier = "protected override";
                else if (injectData.IsSealed)
                    virtualModifier = "private";
                else
                    virtualModifier = "protected virtual";

                // Report dependencies implementation

                source.AppendLine($$"""
                        {{virtualModifier}} Type[] GeneratedReportDependencies(int childCount)
                        {
                    """);

                if (injectData.BaseTypeIsInjector)
                {
                    source.AppendLine($$"""
                                var types = base.GeneratedReportDependencies(childCount + {{injectData.Fields.Length}});
                        """);
                }
                else
                {
                    source.AppendLine($$"""
                                var types = new Type[childCount + {{injectData.Fields.Length}}];
                        """);
                }

                for (var i = 0; i < injectData.Fields.Length; i++)
                {
                    var field = injectData.Fields[i];
                    source.AppendLine(
                        $"        types[childCount + {i}] = typeof({field.TypeName});");
                }

                source.AppendLine("""
                            return types;
                        }

                    """);

                // Inject dependencies implementation

                source.AppendLine($$"""
                        {{virtualModifier}} void GeneratedInjectDependencies(ReadOnlySpan<object> dependencies)
                        {
                    """);

                if (injectData.BaseTypeIsInjector)
                {
                    source.AppendLine($$"""
                                base.GeneratedInjectDependencies(dependencies[{{injectData.Fields.Length}}..]);
                        """);
                }

                for (var i = 0; i < injectData.Fields.Length; i++)
                {
                    var field = injectData.Fields[i];
                    source.AppendLine(
                        $"        this.{field.Name} = ({field.TypeName})dependencies[{i}];");
                }

                source.AppendLine("""
                        }
                    """);

                source.Append("}");

                if (containingTypesEnd != "")
                    source.AppendLine(containingTypesEnd);

                productionContext.AddSource($"{injectData.FileName}.g.cs", source.ToString());
            });
    }

    private static InjectorTypeData? MakeInjectorDataForType(
        INamedTypeSymbol type,
        INamedTypeSymbol depAttribute,
        INamedTypeSymbol depInjector,
        HashSet<INamedTypeSymbol> allTypes,
        CancellationToken cancel)
    {
        var fileName = type
            .ToDisplayString()
            .Replace('<', '{')
            .Replace('>', '}');

        var fields = GetInjectedFields(depAttribute, type);
        var baseTypeIsInjector = BaseTypeIsInjector(type, depInjector, allTypes);
        var partial = Helpers.IsPartial(type, cancel);
        if (!partial)
            return null;

        var typeDeclaration = Helpers.GetPartialTypeDeclarationData(type);
        var containingDecls = Helpers.GenerateContainingTypeData(type, cancel);
        if (containingDecls == null)
            return null;

        var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();

        return new InjectorTypeData(
            fileName,
            baseTypeIsInjector,
            fields,
            ns,
            typeDeclaration,
            containingDecls.Value,
            type.IsSealed);
    }

    private static ImmutableArray<DependencyFieldData> GetInjectedFields(INamedTypeSymbol dependencyAttributeType, INamedTypeSymbol type)
    {
        var fields = new List<DependencyFieldData>();
        foreach (var member in type.GetMembers())
        {
            ITypeSymbol fieldType;
            if (member is IFieldSymbol field)
                fieldType = field.Type;
            else if (member is IPropertySymbol propertySymbol)
                fieldType = propertySymbol.Type;
            else
                continue;

            if (member is not IFieldSymbol or IPropertySymbol)
                continue;

            if (member.IsStatic)
                continue;

            var isDependency = member.GetAttributes().Any(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass!, dependencyAttributeType));

            if (isDependency)
                fields.Add(new DependencyFieldData(member.Name, fieldType.ToDisplayString()));
        }
        return fields.ToImmutableArray();
    }

    private static bool BaseTypeIsInjector(
        INamedTypeSymbol type,
        INamedTypeSymbol typeDependencyInjector,
        HashSet<INamedTypeSymbol> allInjectable)
    {
        if (type.BaseType == null)
            return false;

        foreach (var @interface in type.AllInterfaces)
        {
            if (SymbolEqualityComparer.Default.Equals(@interface, typeDependencyInjector))
                return true;
        }

        while (type.BaseType is { } baseBase)
        {
            if (baseBase.IsGenericType && !baseBase.IsUnboundGenericType)
                baseBase = baseBase.ConstructedFrom;

            if (allInjectable.Contains(baseBase))
                return true;

            type = baseBase;
        }

        return false;
    }
}
