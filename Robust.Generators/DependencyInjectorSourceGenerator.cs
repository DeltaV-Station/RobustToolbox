using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;


namespace Robust.Generators;

[Generator]
public sealed class DependencyInjectorSourceGenerator : IIncrementalGenerator
{
    private const string DependencyAttributeName = "Robust.Shared.IoC.DependencyAttribute";
    private const string DependencyInjectorName = "Robust.Shared.IoC.IDependencyInjector";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find field declarations that have [Dependency],
        // save the type they're declared on.
        var injectableTypeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            DependencyAttributeName,
            static (node, _) => node is { Parent.Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax } }
                or { Parent.Parent: PropertyDeclarationSyntax { Parent: ClassDeclarationSyntax } },
            static (syntaxContext, _) =>
            {
                return (ClassDeclarationSyntax)syntaxContext.TargetNode.Parent!.Parent!.Parent!;
            }).Collect().WithTrackingName("asdf");

        context.RegisterSourceOutput(
            injectableTypeDeclarations.Combine(context.CompilationProvider),
            (productionContext, tuple) =>
            {
                var cancel = productionContext.CancellationToken;
                var (typeDecls, compilation) = tuple;

                var dependencyAttributeType = compilation.GetTypeByMetadataName(DependencyAttributeName);
                var dependencyInjectorType = compilation.GetTypeByMetadataName(DependencyInjectorName);
                if (dependencyAttributeType == null || dependencyInjectorType == null)
                    return;

                var types = typeDecls
                    .Select(x => compilation.GetSemanticModel(x.SyntaxTree).GetDeclaredSymbol(x, cancel))
                    .OfType<INamedTypeSymbol>()
                    .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default)
                    .ToImmutableArray();

                foreach (var type in types)
                {
                    var symbolName = type
                        .ToDisplayString()
                        .Replace('<', '{')
                        .Replace('>', '}');

                    var fields = GetInjectedFields(dependencyAttributeType, type);

                    var baseTypeIsInjector = BaseTypeIsInjector(type, dependencyInjectorType, types);

                    var partial = Helpers.IsPartial(type, cancel);
                    var (containingTypesStart, containingTypesEnd, allContainingPartial) =
                        Helpers.GenerateContainingTypeCode(type);

                    partial &= allContainingPartial;
                    if (!partial)
                        continue;

                    var source = new StringBuilder();
                    source.AppendLine("""
                        // <auto-generated/>
                        using System;
                        using System.Runtime.CompilerServices;
                        using Robust.Shared.IoC;

                        """);

                    if (!type.ContainingNamespace.IsGlobalNamespace)
                    {
                        source.AppendLine($"""
                            namespace {type.ContainingNamespace.ToDisplayString()};

                            """);
                    }

                    if (containingTypesStart != "")
                        source.AppendLine(containingTypesStart);

                    source.AppendLine($$"""
                        {{Helpers.GetPartialTypeDefinitionLine(type)}}{{(baseTypeIsInjector ? "" : " : IDependencyInjector")}}
                        {
                        """);

                    if (!baseTypeIsInjector)
                    {
                        source.AppendLine("""
                                Type[] IDependencyInjector.ReportDependencies()
                                {
                                    return GeneratedReportDependencies(0);
                                }

                                void IDependencyInjector.InjectDependencies(ReadOnlySpan<object> dependencies)
                                {
                                    GeneratedInjectDependencies(dependencies);
                                }

                            """);
                    }

                    string virtualModifier;
                    if (baseTypeIsInjector)
                        virtualModifier = "protected override";
                    else if (type.IsSealed)
                        virtualModifier = "private";
                    else
                        virtualModifier = "protected virtual";

                    // Report dependencies implementation

                    source.AppendLine($$"""
                            {{virtualModifier}} Type[] GeneratedReportDependencies(int childCount)
                            {
                        """);

                    if (baseTypeIsInjector)
                    {
                        source.AppendLine($$"""
                                    var types = base.GeneratedReportDependencies(childCount + {{fields.Count}});
                            """);
                    }
                    else
                    {
                        source.AppendLine($$"""
                                    var types = new Type[childCount + {{fields.Count}}];
                            """);
                    }

                    for (var i = 0; i < fields.Count; i++)
                    {
                        var field = fields[i];
                        source.AppendLine(
                            $"        types[childCount + {i}] = typeof({field.type.ToDisplayString()});");
                    }

                    source.AppendLine("""
                                return types;
                            }

                        """);

                    // Inject dependencies implementation

                    source.AppendLine($$"""
                            {{virtualModifier}} void GeneratedInjectDependencies(ReadOnlySpan<object> dependencies)
                            {
                        """);

                    if (baseTypeIsInjector)
                    {
                        source.AppendLine($$"""
                                    base.GeneratedInjectDependencies(dependencies[{{fields.Count}}..]);
                            """);
                    }

                    for (var i = 0; i < fields.Count; i++)
                    {
                        var field = fields[i];
                        source.AppendLine(
                            $"        this.{field.field.Name} = ({field.type.ToDisplayString()})dependencies[{i}];");
                    }

                    source.AppendLine("""
                            }
                        """);

                    source.Append("}");

                    if (containingTypesEnd != "")
                        source.AppendLine(containingTypesEnd);

                    productionContext.AddSource($"{symbolName}.g.cs", source.ToString());
                }
            });
    }

    private static List<(ISymbol field, ISymbol type)> GetInjectedFields(INamedTypeSymbol dependencyAttributeType, INamedTypeSymbol type)
    {
        var fields = new List<(ISymbol field, ISymbol type)>();
        foreach (var member in type.GetMembers())
        {
            ITypeSymbol fieldType;
            if (member is IFieldSymbol field)
                fieldType = field.Type;
            else if (member is IPropertySymbol propertySymbol)
                fieldType = propertySymbol.Type;
            else
                continue;

            if (member is not IFieldSymbol or IPropertySymbol)
                continue;

            if (member.IsStatic)
                continue;

            var isDependency = member.GetAttributes().Any(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass!, dependencyAttributeType));

            if (isDependency)
                fields.Add((member, fieldType));
        }

        return fields;
    }

    private static bool BaseTypeIsInjector(
        INamedTypeSymbol type,
        INamedTypeSymbol typeDependencyInjector,
        ImmutableArray<INamedTypeSymbol> allInjectable)
    {
        if (type.BaseType == null)
            return false;

        foreach (var @interface in type.AllInterfaces)
        {
            if (SymbolEqualityComparer.Default.Equals(@interface, typeDependencyInjector))
                return true;
        }

        while (type.BaseType is { } baseBase)
        {
            if (baseBase.IsGenericType && !baseBase.IsUnboundGenericType)
                baseBase = baseBase.ConstructedFrom;

            if (allInjectable.Contains(baseBase, SymbolEqualityComparer.Default))
                return true;

            type = baseBase;
        }

        return false;
    }
}
