using System.Collections.Generic;
using System.Runtime.InteropServices;
using Robust.Client.AutoGenerated;
using Robust.Client.Profiling;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.IoC;
using Robust.Shared.Log;
using Robust.Shared.Maths;
using Robust.Shared.Profiling;
using Robust.Shared.Utility.Collections;

namespace Robust.Client.UserInterface;

[GenerateTypedNameReferences]
internal sealed partial class ProfTree : Control
{
    public const float TreeLevelMargin = 16;

    [Dependency] private readonly ProfManager _prof = default!;
    [Dependency] private readonly ProfViewManager _profViewMgr = default!;

    private ProfViewManager.Snapshot? _snapshot;
    public long Frame;

    private readonly TreeExpand _treeExpand = new();

    public ProfTree()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public void LoadSnapshot(ProfViewManager.Snapshot snapshot)
    {
        _snapshot = snapshot;
    }

    public void RebuildTree()
    {
        if (_snapshot == null)
            return;

        TreeRoot.RemoveAllChildren();

        ref var buf = ref _snapshot.Buffer;
        var indexIdx = _profViewMgr.GetIndexOfFrame(Frame, _snapshot);
        if (indexIdx == 0)
        {
            Logger.WarningS("prof.ui", $"Unable to find index for frame: {Frame}");
            return;
        }

        // Index for this frame's data.
        ref var index = ref _snapshot.Buffer.Index(indexIdx);

        // The frame must be wrapped in a whole group. We display this group.
        var i = index.EndPos - 1;
        ref var logEnd = ref buf.Log(i);
        var controls = new ValueList<Control>();

        // Create child controls.
        var countDict = new Dictionary<int, int>();
        var totalFrameTime = ProfGraphView.GetFrameTime(buf, index);
        var (totalCounts, _) = GetTotalGroupCounts(buf, i, logEnd.GroupEnd.StartIndex);

        for (; i >= index.StartPos; i--)
        {
            ref var log = ref buf.Log(i);
            RebuildTreeAddControls(
                buf,
                index,
                totalFrameTime,
                ref i,
                ref log,
                ref controls,
                totalCounts,
                countDict,
                _treeExpand,
                2);
        }

        /*
        TreeInsertGroup(
            buf,
            index,
            ProfGraphView.GetFrameTime(buf, index),
            ref i,
            ref logEnd.GroupEnd,
            ref controls,
            (logEnd.GroupEnd.StringId, 1),
            _treeExpand,
            2f);
            */

        // Header.
        // Yeah we destroy this every time I bodged it in.
        TreeRoot.AddChild(new ProfAltBackground { Children = { new ProfTreeLine
        {
            Text = { Text = "Thing" },
            SideLabel = { Text = "Misc" },
            TimeLabel = { Text = "Time" },
            PercentTimeLabel = { Text = "Time%" },
            AllocLabel = { Text = "Alloc" },
            PercentAllocLabel = { Text = "Alloc%" },
        } } });

        // Reverse insert to fix backwards order.
        // This shouldn't even have more than 1 element but whatever.
        for (var c = controls.Count - 1; c >= 0; c--)
        {
            TreeRoot.AddChild(controls[c]);
        }

        // Do a final pass to assign the alternating background colors.
        // Easier to do here than to do it while we're creating the controls.
        var alt = true;
        foreach (var child in TreeRoot.Children)
        {
            DoAltBackgroundsRecursive(child, ref alt);
        }
    }

    private static void DoAltBackgroundsRecursive(Control control, ref bool alt)
    {
        switch (control)
        {
            case ProfAltBackground altBg:
                altBg.IsAltBackground = alt;
                alt ^= true;
                break;

            case ProfTreeEntry entry:
                entry.AltBG.IsAltBackground = alt;
                alt ^= true;

                foreach (var child in entry.ChildEntryContainer.Children)
                {
                    DoAltBackgroundsRecursive(child, ref alt);
                }

                break;
        }
    }

    private void RebuildTreeAddControls(
        in ProfBuffer buffer,
        in ProfIndex index,
        in TimeAndAllocSample totalFrameTime,
        ref long i,
        ref ProfLog log,
        ref ValueList<Control> insertInto,
        Dictionary<int, int> totalCounts,
        Dictionary<int, int> countDict,
        TreeExpand expandParent,
        float margin)
    {
        switch (log.Type)
        {
            case ProfLogType.Value:
                TreeInsertSample(totalFrameTime, ref insertInto, log.Value.StringId, log.Value.Value, margin);
                break;

            case ProfLogType.GroupEnd:
                var stringId = log.GroupEnd.StringId;

                ref var count = ref CollectionsMarshal.GetValueRefOrAddDefault(countDict, stringId, out _);
                count += 1;
                var totalCount = totalCounts[stringId];

                var stringI = totalCount - count;

                TreeInsertGroup(
                    buffer,
                    index,
                    totalFrameTime,
                    ref i,
                    ref log.GroupEnd,
                    ref insertInto,
                    (stringId, stringI),
                    expandParent,
                    margin);
                break;
        }
    }

    private void TreeInsertSample(in TimeAndAllocSample totalFrameTime, ref ValueList<Control> insertInto, int stringId, in ProfValue value, float margin)
    {
        var treeLine = new ProfTreeLine();
        treeLine.Margin = new Thickness(treeLine.Margin.Left + margin + 12 + 2, 0, 0, 0);
        FillTreeLine(totalFrameTime, treeLine, stringId, value);
        insertInto.Add(new ProfAltBackground { Children = { treeLine } });
    }

    private void TreeInsertGroup(
        in ProfBuffer buffer,
        in ProfIndex index,
        in TimeAndAllocSample totalFrameTime,
        ref long i,
        ref ProfLogGroupEnd logEnd,
        ref ValueList<Control> insertInto,
        (int str, int i) expandId,
        TreeExpand expandParent,
        float margin)
    {
        i -= 1;

        var (totalCounts, anyChildren) = GetTotalGroupCounts(buffer, i, logEnd.StartIndex);

        if (!anyChildren)
        {
            // Node has no children we can display. Just insert it as if it's a sample and move along.
            TreeInsertSample(totalFrameTime, ref insertInto, logEnd.StringId, logEnd.Value, margin);
            i = logEnd.StartIndex;
            return;
        }

        var groupControl = new ProfTreeEntry(this, expandParent, expandId, margin);
        FillTreeLine(totalFrameTime, groupControl.TextLine, logEnd.StringId, logEnd.Value);

        insertInto.Add(groupControl);

        // Look up in the parent's expand data whether we're expanded.
        var expand = expandParent.ExpandedItems.GetValueOrDefault(expandId);
        if (expand is not { Enabled: true })
        {
            // Note expanded. Skip!
            i = logEnd.StartIndex;
            return;
        }

        groupControl.Arrow.Rotated = true;

        // Create child controls.
        var children = new ValueList<Control>();
        var countDict = new Dictionary<int, int>();

        for (; i >= index.StartPos; i--)
        {
            ref var log = ref buffer.Log(i);
            if (log.Type == ProfLogType.GroupStart)
                break;

            RebuildTreeAddControls(
                buffer,
                index,
                totalFrameTime,
                ref i,
                ref log,
                ref children,
                totalCounts,
                countDict,
                expand,
                margin + TreeLevelMargin);
        }

        // Insert child controls in reverse so the order checks out.
        for (var c = children.Count - 1; c >= 0; c--)
        {
            groupControl.ChildEntryContainer.AddChild(children[c]);
        }
    }

    private static (Dictionary<int, int> counts, bool anyChildren) GetTotalGroupCounts(
        in ProfBuffer buffer,
        long i,
        long startIdx)
    {
        var anyChildren = false;
        var dict = new Dictionary<int, int>();

        for (; i > startIdx; i--)
        {
            ref var log = ref buffer.Log(i);

            anyChildren |= log.Type is ProfLogType.GroupEnd or ProfLogType.Value;

            if (log.Type != ProfLogType.GroupEnd)
                continue;

            i = log.GroupEnd.StartIndex;
            ref var val = ref CollectionsMarshal.GetValueRefOrAddDefault(dict, log.GroupEnd.StringId, out _);
            val += 1;
        }

        return (dict, anyChildren);
    }

    private void FillTreeLine(
        in TimeAndAllocSample totalFrameTime,
        ProfTreeLine line,
        int stringId,
        in ProfValue value)
    {
        line.Text.Text = _prof.GetString(stringId);

        switch (value.Type)
        {
            case ProfValueType.TimeAllocSample:
                line.TimeLabel.Text = $"{value.TimeAllocSample.Time * 1000:N2} ms";
                line.PercentTimeLabel.Text = $"{value.TimeAllocSample.Time / totalFrameTime.Time:P2}";
                line.AllocLabel.Text = $"{value.TimeAllocSample.Alloc} B";
                line.PercentAllocLabel.Text = $"{value.TimeAllocSample.Alloc / (float) totalFrameTime.Alloc:P2}";
                break;
            case ProfValueType.Int32:
                line.SideLabel.Text = value.Int32.ToString();
                break;
            case ProfValueType.Int64:
                line.SideLabel.Text = value.Int64.ToString();
                break;
            default:
                line.SideLabel.Text = "???";
                break;
        }
    }

    internal sealed class TreeExpand
    {
        public bool Enabled = true;
        public readonly Dictionary<(int str, int i), TreeExpand> ExpandedItems = new();
    }
}
